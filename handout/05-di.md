# Part 5: Dependency Injection #

- Move HTTP to a Class

Angular 2 Dependency Injection
==============================

Dependency injection (DI) was a core feature in Angular 1.x, and that has not 
changed in Angular 2.  DI is a programming concept that predates Angular.  The 
purpose of DI is to simplify dependency management in software components. By
reducing the amount of information a component needs to know about its
dependencies, unit testing can be made easier, and code is more likely to be
flexible.

Angular 2 improves on Angular 1.x's DI model by unifying Angular 1.x's
two injection systems.  Tooling issues with respect to static analyis, and
minifcation have also been fixed in Angular 2.  Namespace collisions have also
been addressed in Angular 2.

## Simple Service Example

This example demonstrates injecting Angular's http service into a TypeScript
class

```js

import {Injectable} from 'angular2/core';
// import the dependency for its _typings_
// *note* Http is _not_ used/instantiated in this module, it is injected
import {Http} from 'angular2/http';

@Injectable() // <- do not forget brackets after @Injectable!!
export class Dependent {
constructor(public http:Http) {}
someMethod() {
    this.http.get()
    ...
}
}

```

Dependent is a simple TypeScript class that has been decorated with 
`@Injectable`.  This [decorator][pascalDIservice] is a shortcut for a more
verbose `@Inject` syntax.  This decorator essentially tells Angular 2 that this
class is going to be injected with dependencies.  Angular 1.x developers can
think of it like `/* @ngInject */`.

This example is also odd in that `Http` is imported even though it's going to be
injected.  This import statement only pulls in the Http module from Angular 2.
The Angular 2 injector is ultimately responsible for _instantiating_ `Http`, and
_providing_ it to `Dependent`

## Simple Component Example

In this example we have a custom service:

```js

import {Injectable} from 'angular2/core';

@Injectable()
export class CustomService {
getData() {
    return 'fancy data';
}
}

```

Which is a dependency of  a simple component:

```js

import {Component} from 'angular2/core';
import {CustomService} from './custom-service';

@Component({
selector: 'simple-component',
template: '<div>{{ output }}</div>',
providers: [CustomService]
})
export class SimpleComponent {
constructor(private customService: CustomService) {
    this.output = customService.getData();
}
output: string;
}

```

Using DI with components is the same as with plain services.  The important
difference in this example is the `providers` array in the component decorator.
The `providers` array is a mechanism for letting Angular 2's injector know about
`CustomService`, and how to build it.  In this example `providers` was given
only a class name, and Angular _inferred_ what to do with it.

## Using `providers` to Specify Alternate `CustomService`'s

The `providers` mechanism allows the programmer to specify mechanisms other than
classes.  The above component example's `providers` array is really just a
shorthand for:

```js

import {provide} from 'angular2/core';

...
providers: [provide(CustomService, {useClass: CustomService})]
...

```

The shorthand syntax eliminates a _lot_ of boilerplate.  The longhand syntax
hints at the power of Angular 2's injector.

Instead of using a formal class in the previous example, it could be re-written
to use an inline object.  (In the real world the formal class is likely the
better option)

```js

import {Component} from 'angular2/core';
import {provide} from 'angular2/core';

var mockService = { getData: () => 'fancy data' };

@Component({
selector: 'simple-component',
template: '<div>{{ output }}</div>',
providers: [provide(CustomService, { useValue: mockService })]
})
export class SimpleComponent {
constructor(private customService: CustomService) {
    this.output = customService.getData();
}
output: string;
}

```

In this example Angular 2 knows that `CustomService` is a "value", and instead
of instantiating under the hood (`new CustomService`), Angular 2 will simply
return the value _provided_.

## Singletons

Angular 2 injectors (generally) return singletons.  That is, in the previous 
example, any _child_ components of `SimpleComponent` will receive the _same_
`CustomService` that `SimpleComponent` got.

@todo determine if `useFactory` returns singletons or not, explain `useFactory`

## The Injector Tree

In Angular 2 there is not just one injector per application, there is _at least_
one injector per application.  Injectors are organized in a tree that parallels
Angular 2's component tree.

The injector tree does _not_ make a new injector for every component.  The
injector tree _does_ make a new injector for every component with a `providers`
array in its decorator.  Components that have no `providers` array look to their
parent component for an injector. If the parent does not have an injector, it
looks up on, and on until it reaches the root injector.

_Warning:_ be careful with `provider` arrays.  If a child component is decorated
with a `providers` array, and that array contains dependencies that were _also_
requested in the parent component(s) the dependencies the child receives will
_shadow_ the parent dependencies.  This can have all sorts of negative 
consequences.

@todo images of trees from the docs


[SODi]: http://stackoverflow.com/questions/130794/what-is-dependency-injection "Community Answers To What Is DI?"
[pascalDI]: http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html "Dependency Injection in Angular 2"
[pascalDIservice] http://blog.thoughtram.io/angular/2015/09/17/resolve-service-dependencies-in-angular-2.html "Service in Service DI"
[a2DImanual]: https://angular.io/docs/ts/latest/guide/dependency-injection.html "Angular 2's Beta docs for DI"